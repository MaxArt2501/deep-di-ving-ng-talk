---
import Code from '../components/Code.astro';
import SvgCode from '../components/SvgCode.astro';
---

<p-slide class="align-center gap-1" flex="row">
	<!--- Let's suppose we have a TABLE_CONFIG token that allows us to define the configuration of a table. -->
	<p-notes p-group="data">Its columns, its actions on rows, etc.</p-notes>
	<p-notes p-group="multi">Let's not forget multi: true because we can have more than one table config, right?</p-notes>
	<p-notes p-group="wrap">This token value might as well be defined in the root injector, right in the app.config file</p-notes>
	<p-notes p-group="acme">In the same file, we can import the tokens from a client customization package, like this</p-notes>
	<p-notes p-group="acme">And we'd be good, right? All we need to do is to define every token here.
		But doing so, we're actually losing something. The first thing would be...</p-notes>
	<Code code={`{#:wrap;insert{// app.config.ts
}#}{#:acme;insert{import { {#:acme;highlight{tokens as acmeTokens}#} } from '@client/acme';

}#}{#2:wrap;insert{export const appConfig: ApplicationConfig = {
  providers: [
}#}{#:wrap;reveal{    }#}{
{#:wrap;reveal{    }#}  provide: TABLE_CONFIG{#:data;reveal{,}#}
{#:data;insert{{#:wrap;reveal{    }#}  useValue: {
{#:wrap;reveal{    }#}    name: 'fruits',
{#:wrap;reveal{    }#}    columns: [...],
{#:wrap;reveal{    }#}    actions: [...],
{#:wrap;reveal{    }#}    ...
{#:wrap;reveal{    }#}  }{#:multi;reveal{,}#}
}#}{#:multi;insert{{#:wrap;reveal{    }#}  multi: true
}#}{#:wrap;reveal{    }#}}{#:acme;reveal{,}#}
{#3:acme;insert{    ...{#:acme;highlight{acmeTokens}#}
}#}{#:wrap;insert{  ]
};}#}`} class="s05 self-start"/>
	<div flex="column" class="s05 justify-end align-center" p-fragment p-effect="reveal" p-group="acme">
		<svg viewBox="0 0 40 40" style="  width: 4em; margin-bottom: -.5em; isolation: isolate;">
			<use href="#package-client" width="40" height="40" />
		</svg>
		<Code code={`export const {#:acme;highlight{tokens}#} = [{
	provide: TABLE_CONFIG,
	useValue: {
		name: 'fruits',
		columns: [{...}]
	},
	multi: true
}];`}/>
	</div>
	<p-fragment class="overlay-banner h1">
		Colocation
		<!--- Meaning that the basic table definition is *not* in the same component of table's page.
			Everything is in the root, possibly overcrowding the app.config file -->
	</p-fragment>
</p-slide>
<p-slide effect="fade" flex="row" class="gap-1">
	<!--- In order to have the configuration colocated inside the feature, we can... -->
	<p-notes p-group="extract">extract the token value in a separate file and import it in the root config</p-notes>
	<p-notes p-group="extract">But then we'd have to repeat that for every configuration, for tables, toolbars, navigation, actions, etc.
		and the root config is still cluttered and unstructured</p-notes>
	<p-notes p-group="instead">So we want to reduce those imports&hellip;</p-notes>
	<div flex="column" class="gap-1">
		<Code id="appConfig" code={`// app.config.ts
import { tokens as acmeTokens } from '@client/acme';
{#:extract;insert{{#:instead;strike{import fruitTableConfig from './fruits/fruit-table';}#}
}#}{#:intermediate;insert{import tables from './tables';
}#}
export const appConfig: ApplicationConfig = {
  providers: [
{#:extract;-insert{








}#}    {#:instead;strike{{#:extract;reveal{fruitTableConfig}#}{#:extract;-reveal{ }#},}#}
{#:intermediate;insert{    ...tables,
}#}    ...acmeTokens
  ]
};`} class="s05"/>
		<Code p-fragment p-group="intermediate" p-effect="insert" code={`// tables.ts
import fruitTableConfig from 'fruits/fruit-table';
import shopTableConfig from 'shops/shop-table';
...
export default [fruitTableConfig, ...];`} class="s05"/>
	</div>
	<div flex="column" class="gap-1">
		<Code p-fragment p-group="extract" id="fruitTableConfig" code={`{#:extract;insert{// fruit-table.ts
}#}{#:extract;reveal{export default }#}{
  provide: TABLE_CONFIG,
  useValue: {
    name: 'fruits',
    columns: [...],
    actions: [...],
    ...
  },
  multi: true
}{#:extract;reveal{;}#}`} class="s05"/>
			<p-notes p-group="intermediate">and create intermediate files that collect those configurations
					either by feature, or token type, or whatever, and import them once in app.config</p-notes>
		<p-fragment class="s06">Repeat for:
			<ul class="no-margins">
				<li>toolbars</li>
				<li>navigation</li>
				<li>actions</li>
				<li>&hellip;</li>
			</ul>
			<!--- And... it's still not pretty. Now we have to maintain a bunch of intermediate files to mimic a fraction of
				what true colocation is -->
			<!--- In short, it's not the maintainability we were aiming for -->
		</p-fragment>
	</div>
</p-slide>
<p-slide_>
	<!--- Maybe you'd say: "Wait a second! Isn't there a `providedIn` option when creating a token?" -->
	<!--- Problem is, even if we use it, it has effect only when providing the `factory` method too, which
		generates a *default* value, meaning that it's executed only if there aren't other provided values. -->
	<!--- This also means it doesn't work with multi: true -->
	<Code code="{ providedIn: 'root' }â“" theme="github-light" class="h4 self-center"/>
	<Code code={`export const MY_FRUIT = new InjectionToken('fruit'{#1;reveal{, {}#}{#1;insert{	providedIn: 'root'{#2;reveal{,}#}}#}{#2;insert{	factory: () => 'bananas'}#}{#1;reveal{}}#});`} p-fragment class="s05 self-center" />
	<p-fragment class="big-x" style="width: 12em; inset: auto calc(50% - 6em)"><!--- In short, this cannot be used either --></p-fragment>
</p-slide_>
<p-slide>
	<!--- In order to have these token values actually colocated with the view that's going to use them -->
	<p-notes p-group="provide">we're going to provide them inside our component (in this case, the config of the table)</p-notes>
	<p-notes p-group="inject">and then inject them and merge all the values</p-notes>
	<p-notes p-group="use">and pass the final result to the table component</p-notes>
	<Code code={`{#:provide;insert{import fruitTableConfig from './fruit-table';
{#:inject;insert{import { mergeConfigs } from '../utils/table';
}#}
}#}@Component({
	selector: 'my-fruits',
{#:use;insert{	template: '<my-table [config]="config"/>'
}#}{#:provide;insert{	providers: [fruitTableConfig],
}#}	standalone: true
})
export class FruitList {
{#:inject;insert{	configs: TableConfig[] = inject(TABLE_CONFIG);

	config = mergeConfigs(this.configs);
}#}}`} class="s05 self-center"/>
	<p-fragment class="big-x" style="width: 3em; inset: 55.5% auto auto 51%">
		<!--- But, as we've seen, it doesn't work like that.
			It will always return the values for the first injector that contains one, in this case the component's element injector. -->
		<!--- I guess it's time to welcome you into the magical world of... -->
	</p-fragment>
</p-slide>
<p-slide>
	<div class="h1 center bold">
		<span p-effect="dropping from" style="--from-y: -50cqh"><em>C</em>ustom</span>
		<p-fragment p-effect="dropping from" style="--from-y: -50cqh"><em>I</em>nject</p-fragment>
		<p-fragment p-effect="dropping from" style="--from-y: 50cqh;"><em>F</em>unctions
			<!--- Similar to what's happened for React with hooks, the introduction of the `inject` function
				in Angular has paved the road for new ways to provide data in injection contexts. So not just the
				usual DI way, but we can tweak it a little... -->
		</p-fragment>
	</div>
</p-slide>
<style lang="scss">
	[p-effect~="from"] {
		display: inline-block;
	}
</style>
<p-slide>
	<!--- CIFs are used to inject a value retrieved with additional logic. They're convenience helpers that
		saves us the hassle of doing certain things again and again. -->
	<!--- This example here was a common way to retrieve a route parameter. -->
	<div flex="column" class="gap-1 s05 self-center">
		<Code code={`export const injectIdParam = () => toSignal(
	inject(ActivatedRoute).params.pipe(
		map(params => params.id || null)
	),
	{ initialValue: null }
);`} p-effect="fade"/>
		<Code code={`@Component({ ... })
export class Viewer {
	private id = injectIdParam();

	constructor() {
		effect(() => {
			const id = this.id();
			if (id) navigator.sendBeacon(\`/check/\${id}\`);
		});
	}
}`} p-fragment p-effect="insert" p-group="usage"/>
		<p-notes p-group="usage">We know that's outdated now that we have withComponentInputBinding, but still</p-notes>
	</div>
</p-slide>
<p-slide>
	<div class="h3 bold center">What we need</div>
	<ul class="self-center">
		<li p-fragment>get the whole injector chain;</li>
		<li p-fragment>get the tokens from a single injector.</li>
	</ul>
</p-slide>
<p-slide>
	<!--- Let's see how we can build this CIF. Of course it should take a token... And nothing else, actually.
		No options, as its job is well defined as it is -->
	<p-notes p-group="types">Then we can add some type safety, so we have a generic type T to deal with</p-notes>
	<p-notes p-group="array">So that we'll have to return an array of T's, eventually</p-notes>
	<p-notes p-group="climb">Let's try to climb the chain of injectors. First, we get the current injector, using the Injector class as token</p-notes>
	<p-notes p-group="while">Then we iterate while we have an injector. From one injector, we get the parent injector by requesting the Injector class</p-notes>
	<p-notes p-group="skip">but skipping the current injector - otherwise it'd return the injector itself - thus effectively
		climbing the injector chain.</p-notes>
	<p-notes p-group="value">From the injector, we get the token value (or values, if multi)</p-notes>
	<p-notes p-group="self">but telling them to stay in the injector and not climbing to the parent injector if nothing has been found.
		That's why we're also saying that's optional - we can deal with missing values. Also, that takes care of the null injector</p-notes>
	<p-notes p-group="aiic">Almost done! Assert that we're in an inj ctx. Technically not necessary:
		first call to `inject` does that for us, but for debugging purposes we're using aIIC correctly</p-notes>
	<Code code={`{#:climb;insert{import { {#7:aiic;reveal{assertInInjectionContext, }#}inject, Injector } from '@angular/core';
}#}{#0:types;insert{import type { ProviderToken } from '@angular/core';

}#}export function chainInject{#:types;reveal{<T>}#}(token{#:types;reveal{: ProviderToken<T | T[]>}#}){#:types;reveal{: T[]}#} {
{#:aiic;insert{  {#:aiic;highlight{assertInInjectionContext(chainInject)}#};

}#}{#1:array;insert{  const values: T[] = [];
}#}{#:climb;insert{  let injector: Injector | null = inject(Injector);

}#}{#:while;insert{  while (injector) {
{#:value;insert{    const value = injector.get(token, null, {#6:self;highlight{{ self: true, optional: true }}#});
    if (value) values.push(...(Array.isArray(value) ? value : [value]));

}#}    injector = injector.get(Injector, null, {#4:skip;highlight{{ skipSelf: true }}#});
  }

}#}{#:array;insert{  return values;
}#}};`} class="s05 self-center"/>
</p-slide>
<p-slide>
	<!--- That's it! -->
	<p-notes p-group="instead">Instead of `inject`</p-notes>
	<p-notes p-group="chain">we're using `chainInject` and we're set! We'll have all the token values
		defined in every injector of the injector ancestry</p-notes>
	<Code code={`import fruitTableConfig from './fruit-table';
import { mergeConfigs } from '../utils/table';
{#:chain;insert{import { {#:chain;highlight{chainInject}#} } from '../chain-inject';
}#}
@Component({
	selector: 'my-fruits',
	template: '<my-table [config]="config"/>'
	providers: [fruitTableConfig],
	standalone: true
})
export class FruitList {
	configs: TableConfig[] = {#:chain;reveal{{#:chain;highlight{chainInject}#}}#}{#:chain;-reveal{{#0:instead;strike{inject}#}}#}(TABLE_CONFIG);

	config = mergeConfigs(this.configs.filter(cfg => cfg.name === 'fruit'));
}`} class="s05 self-center"/>
</p-slide>
<p-slide>
	<!--- We can actually take advantage of this hierarchical structure -->
	<svg viewBox="-40 0 160 100">
		<path d="M 50 30 S 35 30 35 10"/>
		<path d="M 50 30 S 50 20 50 10"/>
		<path d="M 50 30 S 65 30 65 10"/>
		<path d="M -2.5 30 S -10 30 -10 10"/>
		<path d="M -2.5 30 S 5 30 5 10"/>
		<path d="M 20 50 S 50 50 50 30"/>
		<path d="M 20 50 S -2.5 50 -2.5 30"/>
		<path d="M 20 10 V 30 V 50 V 70 V 90"/>
		<g p-fragment>
			<!--- Suppose we have a table that's being used by two distinct components in the same feature -->
			<path d="M 35 10 S 35 30 50 30" p-effect="drawing" p-fragment="1" style="--length: 27.93px"><!---
				Instead of providing the table configuration twice, we can climb the injector chain
			--></path>
			<path d="M 65 10 S 65 30 50 30" p-effect="drawing" p-fragment="1" style="--length: 27.93px"/>
			<path d="M 50 30 v 0" p-fragment="2"><!---
				And define the table config there. But suppose that one of the components needs to show a slightly
				altered version of the table, one that could be obtained by a simple change... a "customization"
				of sort
			--></path>
		</g>
		<SvgCode code={`{
	provide: TABLE_CONFIG,
	useValue: {
		name: 'fruit',
		columns: [...],
		actions: [...]
	},
	multi: true
}`} x="47" y="40" p-fragment="2">
			<path d="M47,40l3-3 3,3" style="translate: 0 -0.5lh"/>
		</SvgCode>
		<SvgCode code={`ðŸ‘`} x="32" y="20" p-fragment style="font-size: 5px; stroke-width: 0.14em;">
			<path d="M32,20l3-3 3,3" style="translate: 0 -0.5lh"/>
			<g p-notes>And while one component is fine with the default configuration&hellip;</g>
		</SvgCode>
		<SvgCode code={`{
	provide: TABLE_CONFIG,
	useValue: { ... }
}`} x="62" y="20" p-fragment>
			<path d="M62,20l3-3 3,3" style="translate: 0 -0.5lh"/>
			<g p-notes>&hellip; the other alone can provide the changes it needs. This is the kind of
				flexibility we were looking for.</g>
		</SvgCode>
	</svg>
</p-slide>
<style lang="scss">
	#appConfig {
		width: max-content;
		height: fit-content;
	}
	#fruitTableConfig {
		opacity: 1;
		position: relative;
		height: fit-content;
		transform: translate(0, 0);
		transition: transform var(--fragment-duration);
		
		&[aria-hidden='true'] {
			transform: translate(calc(-2.5em - 49ch), 5lh);
			background: none !important;
		}
	}
	path {
		fill: none;

		svg > &:nth-of-type(-n + 8) {
			stroke: #dd0031;
			stroke-width: 6px;
			stroke-linecap: round;
			marker-end: url(#commit);
			marker-mid: url(#commit);
		}
		&:nth-of-type(8) {
			marker-start: url(#commit);
		}
		
		g > & {
			stroke: #002fc3;
			stroke-width: inherit;
			marker-start: url(#commit);
			stroke-linecap: round;
		}
	}
	g {
		&:not(.shiki) {
			transition-property: opacity, stroke-width;
			transition-timing-function: var(--overshoot);
			stroke-width: 6px;
			&[aria-hidden='false'] {
				stroke-width: 8px;
			}
		}
		&.shiki {
			font-size: 3.5px;
			> path {
				fill: inherit;
				stroke: inherit;
				marker-end: none;
				marker-mid: none;
			}
		}
	}
</style>
<style is:global>
	#appConfig [effect='reveal'][aria-hidden='false'] {
		margin-inline-end: -1ch;
	}
</style>
