---
import Code from '../components/Code.astro';
---
<p-slide>
	<!--- This is fine, but we have to write each time something like this -->
	<Code code={`{#:verbose;highlight{{}#}
{#:verbose;highlight{  provide: TABLE_ACTION,}#}
{#:verbose;highlight{  useValue: }#}{#:untyped;highlight red{{}#}
{#:untyped;highlight red{    name: 'edit',}#}
{#:untyped;highlight red{    label: 'Edit',}#}
{#:untyped;highlight red{    icon: 'pencil',}#}
{#:untyped;highlight red{    link: item => [{}, item.id]}#}
{#:untyped;highlight red{  }}#},
{#:forgotten;highlight blue{  multi: true}#}
{#:verbose;highlight{}}#}`} class="self-center"/>
	<p-fragment class="annotation" p-group="verbose" style="inset: 5% auto auto 30%">Verbose ü•±<!---
		First of all, it's verbose, there's a lot of boring boilerplate --></p-fragment>
	<p-fragment class="annotation" p-group="untyped" style="inset: 40% auto auto 60%">Untyped ü´£<!---
		The worst offender is the lack of type information. I can write whatever here, Angular wouldn't blink.
		In certain contexts it's vital, so it's the strength and weakness of Angular's DI system. --></p-fragment>
	<p-fragment class="annotation" p-group="forgotten" style="inset: 70% auto auto 47%">Always forgotten üòÖ<!---
		Lastly, we're going to forget to write the multi: true part. Ask me how I know --></p-fragment>
</p-slide>
<style lang="scss">
	.annotation {
		position: absolute;
		background: #aaa;
		padding: .25em .5em;
		border-radius: .5em;
	}
</style>
<p-slide>
	<div flex="column" class="s05 gap-1 self-center">
		<Code code={`const provideTableAction{#0;reveal{ =}#}
{#0;insert{  (action: TableAction) => {#1;reveal{(}#}{
}#}{#1;insert{    provide: TABLE_ACTION,
    useValue: action,
    multi: true
}#}{#0;insert{  }{#1;reveal{)}#};}#}`}/>
    <Code code={`{
  providers: [
    {#:provide;reveal{provideTableAction(}#}{
{#:provide;-insert{      provide: TABLE_ACTION,
      useValue: {
}#}      {#:provide;-reveal{  }#}name: 'edit',
      {#:provide;-reveal{  }#}label: 'Edit',
      {#:provide;-reveal{  }#}icon: 'pencil',
      {#:provide;-reveal{  }#}link: item => ['/items', item.id]
{#:provide;-insert{      },
      multi: true
}#}    }{#:provide;reveal{)}#}
  ]
}`} p-fragment p-effect="insert"/>
	</div>
</p-slide>
<p-slide>
	<Code code={`{#7;insert{interface ValueOrFactoryProviderFn<T> {
  (value: T): ValueProvider;
  (value: () => T): FactoryProvider;
}}#}function createTokenProvider{#2;reveal{<T>}#}({#0;reveal{token: InjectionToken{#2;reveal{<T[]>}#}}#}) {
{#insert{  return {#7;reveal{(}#}(value{#2;reveal{: T}#}{#5;reveal{ | (() => T)}#}) => ({
    provide: token,
{#6;insert{    ...(typeof value === 'function'
      ? { useFactory: value }
}#}    {#6;reveal{  : { }#}useValue: value{#6;reveal{ })}#},
    multi: true
  }){#7;reveal{) as ValueOrFactoryProviderFn<T>}#};
}#}}
{#insert{
const {#8;highlight{provideTableAction}#} = createTokenProvider(TABLE_ACTION);
}#}{#insert{const {#8;highlight{provideTableConfig}#} = createTokenProvider(TABLE_CONFIG);
const {#8;highlight{provideTableColumn}#} = createTokenProvider(TABLE_COLUMN);}#}
`} class="s05 self-center"/>
</p-slide>
<p-slide>
	<div grid="2" class="gap-1 s05 self-center">
		<Code code="TABLE_CONFIG" style="grid-column-end: span 2" class="center s2"/>
		<Code code={`{
  name: '{#1;highlight blue{articles-k15}#}',
  columns: [...],
  actions: [...]
}`}/>
		<Code code={`{
  name: '{#1;highlight blue{articles-k15}#}',
  columns: [...],
  actions: [...]
}`}/>
		<Code code={`{
  name: '{#2;highlight red{articles-k23}#}',
  columns: [...],
  actions: [...]
}`} p-fragment/>
		<Code code={`{
  name: '{#4;highlight{articles-k*}#}',
  columns: [...],
  actions: [...]
}`} p-fragment p-effect="reveal"/>
	</div>
</p-slide>
<p-slide>
	<Code code={`{#2:filter;insert{import matches from 'wildcard-match';

}#}export function chainInject{#:name;reveal{ByName}#}<T>(
  token: ProviderToken<T | T[]>{#:name;reveal{,}#}
{#:name;insert{  name: string
}#}): T[] {
{#insert{  ...
  const value = injector.get(token, null, { self: true, optional: true });
  if (value) {
    const valueArray = Array.isArray(value) ? value : [value];
{#:filter;insert{    const filtered = valueArray{#:filter;highlight green{.filter(value => matches(value.name)(name))}#};
}#}    values.push(...{#:filter;reveal{filtered}#}{#:filter;-reveal{values}#});
  }
}#}}`} class="s05 self-center"/>
	<p-notes p-fragment p-group="name">So let's add the name</p-notes>
	<p-notes p-fragment p-group="filter">Then filter using the name</p-notes>
</p-slide>
<p-slide>
	<!--- So, instead of using the `chainInject` function we've seen before... -->
	<Code code={`import fruitTableConfig from './fruit-table';
import { mergeConfigs } from '../utils/table';
import { chainInject{#:byName;reveal{ByName}#} } from '../chain-inject';

@Component({
	selector: 'my-fruits',
	template: '<my-table [config]="config"/>'
	providers: [fruitTableConfig],
	standalone: true
})
export class FruitList {
	configs: TableConfig[] = chainInject{#:byName;reveal{ByName}#}(TABLE_CONFIG{#:byName;reveal{, 'fruit'}#});

	config = mergeConfigs(this.configs{#:noFilter;strike{.filter(cfg => cfg.name === 'fruit')}#});
}`} class="s05 self-center"/>
	<p-notes p-group="byName">&hellip; we use this new <code>chainInjectByName</code>&hellip;</p-notes>
	<p-notes p-group="noFilter">&hellip; that automatically filters the values we're interested in for us.</p-notes>
</p-slide>
<p-slide>
	<div class="h1 center bold">The two hardest problems in IT</div>
	<ol class="self-center">
		<li p-fragment>Cache invalidation</li>
		<li p-fragment>Naming things</li>
		<li p-fragment>Off-by-one errors<!--- And I must admit, Copilot got the joke quite well here --></li>
	</ol>
</p-slide>
<p-slide>
	<Code code={`[
  provideTableConfig({
{#insert{{#insert{    name: 'ü§î',
}#}    columns: [...],
    actions: [...],
    itemsPerPage: 20,
    select: 'checkbox'
}#}  })
]`} class="s08 self-center"/>
</p-slide>
<p-slide>
	<div class="h3 bold center">Derive the <em>name</em><br> from the <em>context</em></div>
	<p-fragment class="center">
		I.e.: can we get the name from what we've already named?
		<!--- And you may ask: in what cases it could come in handy? -->
		<!--- It's in those cases where some piece of user interface - i.e. a table, a toolbar, a dashboard, ... - is bound to its context, which is basically the current view -->
	</p-fragment>
</p-slide>
<p-slide class="stack">
	<!--- So, for example, we may have a page that has a table as its main, defining feature. And that could be the case for many different pages of our application.	-->
	<div class="redacted-layout s08">
		<div class="sidebar">
			<div class="logo">Lorem</div>
			<ul>
				<li>
					<b>Section</b>
					<ul>
						<li>First</li>
						<li>Second</li>
						<li>Third</li>
						<li>And more</li>
					</ul>
				</li>
				<li>
					<b>Other</b>
					<ul>
						<li>Second to last</li>
						<li>Last</li>
					</ul>
				</li>
				<li>
					<b>Addition</b>
					<ul>
						<li>Plus one</li>
						<li>And two</li>
					</ul>
				</li>
			</ul>
		</div>
		<div class="header">
			<p>Articles</p>
			<div class="toolbar">
				<kbd>üîç</kbd><kbd>‚ûï</kbd><kbd>‚ö°</kbd>
			</div>
		</div>
		<table>
			<thead>
				<tr>
					<th><span>Id</span></th>
					<th><span>Name</span></th>
					<th><span>Nickname</span></th>
					<th><span>email</span></th>
					<th><span>Orders</span></th>
					<th><span>Actions</span></th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><span>1</span></td>
					<td><span>Leanne Graham</span></td>
					<td><span>Bret</span></td>
					<td><a href="mailto:Sincere@april.biz">Sincere@april.biz</a></td>
					<td><span>92998</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd><kbd>‚ùå</kbd></span></td>
				</tr>
				<tr>
					<td><span>2</span></td>
					<td><span>Ervin Howell</span></td>
					<td><span>Antonette</span></td>
					<td><a href="mailto:Shanna@melissa.tv">Shanna@melissa.tv</a></td>
					<td><span>90566</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd><kbd>‚ùå</kbd></span></td>
				</tr>
				<tr>
					<td><span>3</span></td>
					<td><span>Clementine Bauch</span></td>
					<td><span>Samantha</span></td>
					<td><a href="mailto:Nathan@yesenia.net">Nathan@yesenia.net</a></td>
					<td><span>59590</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd></span></td>
				</tr>
				<tr>
					<td><span>4</span></td>
					<td><span>Patricia Lebsack</span></td>
					<td><span>Karianne</span></td>
					<td><a href="mailto:Julianne.OConner@kory.org">Julianne.OConner@kory.org</a></td>
					<td><span>53919</span></td>
					<td><span><kbd>‚ùå</kbd></span></td>
				</tr>
				<tr>
					<td><span>5</span></td>
					<td><span>Chelsey Dietrich</span></td>
					<td><span>Kamren</span></td>
					<td><a href="mailto:Lucio_Hettinger@annie.ca">Lucio_Hettinger@annie.ca</a></td>
					<td><span>33263</span></td>
					<td><span><kbd style="visibility: hidden">‚úèÔ∏è</kbd></span></td>
				</tr>
				<tr>
					<td><span>6</span></td>
					<td><span>Mrs. Dennis Schulist</span></td>
					<td><span>Leopoldo_Corkery</span></td>
					<td><a href="mailto:Karley_Dach@jasper.info">Karley_Dach@jasper.info</a></td>
					<td><span>23505</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd><kbd>‚ùå</kbd></span></td>
				</tr>
				<tr>
					<td><span>7</span></td>
					<td><span>Kurtis Weissnat</span></td>
					<td><span>Elwyn.Skiles</span></td>
					<td><a href="mailto:Telly.Hoeger@billy.biz">Telly.Hoeger@billy.biz</a></td>
					<td><span>58804</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd></span></td>
				</tr>
				<tr>
					<td><span>8</span></td>
					<td><span>Nicholas Runolfsdottir V</span></td>
					<td><span>Maxime_Nienow</span></td>
					<td><a href="mailto:Sherwood@rosamond.me">Sherwood@rosamond.me</a></td>
					<td><span>45169</span></td>
					<td><span><kbd>‚úèÔ∏è</kbd><kbd>‚ùå</kbd></span></td>
				</tr>
			</tbody>
		</table>
	</div>
	<pre class="names" p-fragment><!--- So it's not a matter of giving just one name --><p-fragment p-effect="insert" p-group="taxon">'stores'
'stores-item'
'stores-item-edit'
'stores-managers'
'stores-managers-contacts'
...<!---
But rather a complete taxonomy of names in order to have them meaningful and predictable. And *that* is hard! -->
<!--- And more than hard: it's also *reduntant*, because we've done something similar again and again while developing the application
--></p-fragment>'articles'<p-fragment p-effect="insert" p-group="taxon">'articles-source'
'articles-source-list'
'articles-source-edit'
'articles-item'
'articles-item-edit'
...
'regions'
'regions-areas'
'regions-areas-item'
...</p-fragment></pre>
</p-slide>
<style lang="scss">
	pre.names {
		background: #fffc;
		border-radius: 1em;
		padding: 1em;
		font-size: 60%;
		font-weight: bold;
		box-shadow: 0 0 1em;
	}
</style>
<p-slide class="justify-start gap-1">
	<div class="h4 bold center">From the component's <em>name</em></div>
	<p-fragment class="stack self-center">
		<!--- You know that thing you put after class? -->
		<Code code={`@Component({
  selector: 'app-fruit-list',
  templateUrl: './fruit-list.html',
  styleUrls: ['./fruit-list.css']
})
export default class {#1;highlight green{FruitList}#} {
  ...
}`} p-fragment p-effect="from" aria-hidden="false" style="--from-x: calc(-50% - 50cqw)" p-group="swipe" class="s08"/>
	<Code code={`const getComponentName = ({#:ar;reveal{route: ActivatedRoute}#}) => {
{#:cn;insert{  return route.component.name;
}#}};
{#:test;insert{
getComponentName(inject(ActivatedRoute))
}#}{#:prob;insert{> "{#highlight{_}#}FruitList"
}#}`} class="s08 self-center" p-fragment p-group="swipe" p-effect="from right"/>
	</p-fragment>
	<p-notes p-group="swipe">And that's something we can easily retrieve</p-notes>
	<p-notes p-group="ar">And we get it from the <code>ActivatedRoute</code>, because</p-notes>
	<p-notes p-group="cn">it stores the component's class, so we can get its name</p-notes>
	<p-notes p-group="test">Problem is, when we use it, what we get</p-notes>
	<p-notes p-group="prob">
		is <em>not</em> the class' intended name, but something that's actually been mangled by the compiler.
		And in production it's even worse.
	</p-notes>
	<p-fragment class="big-x" style="width: 10em; inset: 30%">
		<!--- Can we configure the compiler to avoid this problem? Probably, but maybe it's too much effort -->
	</p-fragment>
</p-slide>
<p-slide class="justify-start gap-1">
	<div class="h4 bold center">From the component's <em>selector</em></div>
	<!--- Oooh, that's a good one! -->
	<p-fragment class="stack self-center">
		<!--- You know that thing you put in the class' decorator? -->
		<Code code={`@Component({
  selector: '{#1;highlight green{app-fruit-list}#}',
  templateUrl: './fruit-list.html',
  styleUrls: ['./fruit-list.css']
})
export default class FruitList {
  ...
}`} p-fragment p-effect="from" aria-hidden="false" style="--from-x: calc(-50% - 50cqw)" p-group="swipe" class="s08"/>
		<Code code={`const getComponentSelector = (route: ActivatedRoute)
{#:cn;insert{  => {#5:as-any;reveal{(}#}route.component{#:as-any;reveal{ as any)}#}
    .{#:cn;highlight green{decorators[0].args[0].selector}#};
}#}
{#:test;insert{getComponentSelector(inject(ActivatedRoute))
> "app-fruit-list"
}#}`} class="s08 self-center" p-fragment p-group="swipe" p-effect="from right"/>
	</p-fragment>
	<p-notes p-group="swipe">Again, we start from the activated route</p-notes>
	<p-notes p-group="cn">And get the component's class, where we can retrieve the decorators applied to it</p-notes>
	<p-notes p-group="test">This one <em>just works!</em></p-notes>
	<p-notes p-group="as-any">Problem is, Angular decorators are <em>private</em>, therefore an implementation detail and we shouldn't rely on them</p-notes>
	<p-fragment class="big-x" style="width: 10em; inset: 30%">
		<!--- Moreover, we're also moving towards the usage of selector-less components -->
	</p-fragment>
</p-slide>
<p-slide class="justify-start gap-1">
	<div class="h4 bold center">From the route's <em>title</em></div>
	<!--- Another good idea that leverages on Angular's new features -->
	<p-fragment class="stack self-center">
		<!--- Set the page's title directly in the route def, rather than using Title -->
		<Code code={`{
  path: 'fruits',
{#1:title;insert{  title: {#2;reveal{() => }#}'{#:title;highlight green{List of all fruits}#}',
}#}  component: FruitList
}`} p-fragment p-effect="from" aria-hidden="false" style="--from-x: calc(-50% - 50cqw)" p-group="swipe" class="s08"/>
		<Code code={`const getRouteTitle = (route: ActivatedRoute) => {
{#:its;insert{  const titleStrategy = inject(TitleStrategy);
}#}{#:cn;insert{  let current: ActivatedRoute | null = route;
  while (current) {
    const title = titleStrategy.getResolvedTitleForRoute(current.snapshot);
    if (title) return title;
    current = current.parent;
  }
}#}};
{#:test;insert{
getRouterTitle(inject(ActivatedRoute))
> "List of all fruits"
}#}`} class="s06 self-center" p-fragment p-group="swipe" p-effect="from right"/>
	</p-fragment>
	<p-notes p-group="swipe">Now you know the drill</p-notes>
	<p-notes p-group="its">Assuming injection context, get the <code>TitleStrategy</code></p-notes>
	<p-notes p-group="cn">Resolve the title for the specific partial route, if any. Otherwise climb the tree</p-notes>
	<p-notes p-group="test">It works, but several issues. First, not all pages might have a title: use explicit names for those cases.</p-notes>
	<p-notes p-group="test">Second: page titles are descriptive, not meant to be stable or unique</p-notes>
	<p-notes p-group="test">Finally, the title could and will probably change depending on the requested resource (e.g. might include the resource's name)</p-notes>
	<p-fragment class="big-x" style="width: 10em; inset: 30%">
		<!--- So, in the end, this one should be tossed too -->
	</p-fragment>
</p-slide>
<p-slide class="justify-start gap-1">
	<div class="h4 bold center">From the route's <em>path</em></div>
	<!--- Attn: not the *resolved* path, but rather the route's configuration. Parameter name, not value -->
	<p-fragment class="stack self-center">
		<Code code={`articles/{#1;highlight red{{#2;-reveal{2493-4321}#}}#}{#2;reveal{{#2;highlight green{:id}#}}#}/edit`} lang="plaintext" p-fragment p-effect="from" aria-hidden="false" style="--from-x: calc(-50% - 50cqw)" p-group="swipe" class="s08"/>
		<Code code={`const getRoutePath = (route: ActivatedRoute) => {
{#:path;insert{  const segments: string[] = [];
  let current: ActivatedRoute | null = route;
  while (current) {
    const { path } = current.{#:cfg;highlight blue{routeConfig}#} ?? {};
    if (path) segments.unshift(path);
    current = current.parent;
  }
  return segments.join('/');
}#}};
{#:test;insert{
getRouterPath(inject(ActivatedRoute))
> "articles/:id:/edit"
}#}`} class="s05 self-center" p-fragment p-group="swipe" p-effect="from right"/>
	</p-fragment>
	<p-notes p-group="swipe">The activated route is always our starting point</p-notes>
	<p-notes p-group="path">We then climb down the route's tree to the root</p-notes>
	<p-notes p-group="cfg">And we take the configuration, not the snapshot, for the mentioned purposes</p-notes>
	<p-notes p-group="test">So we can get what we want</p-notes>
	<p-notes p-group="test">And I know what some of you might say: paths are not id's, they're subject to change too. But honestly, that rarely happens. So yes, we've gone for that</p-notes>
	<p-notes p-group="test">Another detail is that there could be <code>matcher</code> instead of <code>path</code> in the route definition, but not in our case. Otherwise you have to deal</p-notes>
</p-slide>
<p-slide>
	<Code code={`export function chainInject{#:name;-reveal{ByName}#}<T>(
  token: ProviderToken<T | T[]>,
  name{#:name;reveal{?}#}: string
): T[] {
  ...
{#:grp;insert{  if (name === undefined) {
    name = {#:grp;highlight green{getRoutePath}#}(inject(ActivatedRoute));
  }
}#}  const value = injector.get(token, null, { self: true, optional: true });
  if (value) {
    const valueArray = Array.isArray(value) ? value : [value];
    const filtered = valueArray.filter(value => {
{#:filter;insert{      const valueName = value.name
        ?? {#;highlight blue{getRoutePath(injector.get(ActivatedRoute, null, { self: true }))}#};
}#}      return matches(value{#:filter;-reveal{.name}#}{#:filter;reveal{Name}#})(name)
		});
    values.push(...filtered);
  }
}`} class="s05 self-center"/>
</p-slide>
