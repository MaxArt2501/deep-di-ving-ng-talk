---
import Code from '../components/Code.astro';
---
<p-slide>
	<!--- This is fine, but we have to write each time something like this -->
	<Code code={`{#:verbose;highlight{{}#}
{#:verbose;highlight{  provide: TABLE_ACTION,}#}
{#:verbose;highlight{  useValue: }#}{#:untyped;highlight red{{}#}
{#:untyped;highlight red{    name: 'edit',}#}
{#:untyped;highlight red{    label: 'Edit',}#}
{#:untyped;highlight red{    icon: 'pencil',}#}
{#:untyped;highlight red{    link: item => [{}, item.id]}#}
{#:untyped;highlight red{  }}#},
{#:forgotten;highlight blue{  multi: true}#}
{#:verbose;highlight{}}#}`} class="self-center"/>
	<p-fragment class="annotation" p-group="verbose" style="inset: 5% auto auto 30%">Verbose ðŸ¥±<!---
		First of all, it's verbose, there's a lot of boring boilerplate --></p-fragment>
	<p-fragment class="annotation" p-group="untyped" style="inset: 40% auto auto 60%">Untyped ðŸ«£<!---
		The worst offender is the lack of type information. I can write whatever here, Angular wouldn't blink.
		In certain contexts it's vital, so it's the strength and weakness of Angular's DI system. --></p-fragment>
	<p-fragment class="annotation" p-group="forgotten" style="inset: 70% auto auto 47%">Always forgotten ðŸ˜…<!---
		Lastly, we're going to forget to write the multi: true part. Ask me how I know --></p-fragment>
</p-slide>
<style lang="scss">
	.annotation {
		position: absolute;
		background: #aaa;
		padding: .25em .5em;
		border-radius: .5em;
	}
</style>
<p-slide>
	<div flex="column" class="s05 gap-1 self-center">
		<Code code={`const provideTableAction{#0;reveal{ =}#}
{#0;insert{  (action: TableAction) => {#1;reveal{(}#}{
}#}{#1;insert{    provide: TABLE_ACTION,
    useValue: action,
    multi: true
}#}{#0;insert{  }{#1;reveal{)}#};}#}`}/>
    <Code code={`{
  providers: [
    {#:provide;reveal{provideTableAction(}#}{
{#:provide;-insert{      provide: TABLE_ACTION,
      useValue: {
}#}      {#:provide;-reveal{  }#}name: 'edit',
      {#:provide;-reveal{  }#}label: 'Edit',
      {#:provide;-reveal{  }#}icon: 'pencil',
      {#:provide;-reveal{  }#}link: item => ['/items', item.id]
{#:provide;-insert{      },
      multi: true
}#}    }{#:provide;reveal{)}#}
  ]
}`} p-fragment p-effect="insert"/>
	</div>
</p-slide>
<p-slide>
	<Code code={`{#7;insert{interface ValueOrFactoryProviderFn<T> {
  (value: T): ValueProvider;
  (value: () => T): FactoryProvider;
}}#}function createTokenProvider{#2;reveal{<T>}#}({#0;reveal{token: InjectionToken{#2;reveal{<T[]>}#}}#}) {
{#insert{  return {#7;reveal{(}#}(value{#2;reveal{: T}#}{#5;reveal{ | (() => T)}#}) => ({
    provide: token,
{#6;insert{    ...(typeof value === 'function'
      ? { useFactory: value }
}#}    {#6;reveal{  : { }#}useValue: value{#6;reveal{ })}#},
    multi: true
  }){#7;reveal{) as ValueOrFactoryProviderFn<T>}#};
}#}}
{#insert{
const {#8;highlight{provideTableAction}#} = createTokenProvider(TABLE_ACTION);
}#}{#insert{const {#8;highlight{provideTableConfig}#} = createTokenProvider(TABLE_CONFIG);
const {#8;highlight{provideTableColumn}#} = createTokenProvider(TABLE_COLUMN);}#}
`} class="s05 self-center"/>
</p-slide>
<p-slide>
	<div grid="2" class="gap-1 s05 self-center">
		<Code code="TABLE_CONFIG" style="grid-column-end: span 2" class="center s2"/>
		<Code code={`{
  name: '{#1;highlight blue{articles-k15}#}',
  columns: [...],
  actions: [...]
}`}/>
		<Code code={`{
  name: '{#1;highlight blue{articles-k15}#}',
  columns: [...],
  actions: [...]
}`}/>
		<Code code={`{
  name: '{#2;highlight red{articles-k23}#}',
  columns: [...],
  actions: [...]
}`} p-fragment/>
		<Code code={`{
  name: '{#4;highlight{articles-k*}#}',
  columns: [...],
  actions: [...]
}`} p-fragment p-effect="reveal"/>
	</div>
</p-slide>
<p-slide>
	<Code code={`{#2:filter;insert{import matches from 'wildcard-match';

}#}export function chainInject{#:name;reveal{ByName}#}<T>(
  token: ProviderToken<T | T[]>{#:name;reveal{,}#}
{#:name;insert{  name: string
}#}): T[] {
{#insert{  ...
  const value = injector.get(token, null, { self: true, optional: true });
  if (value) {
    const valueArray = Array.isArray(value) ? value : [value];
{#:filter;insert{    const filtered = valueArray{#:filter;highlight green{.filter(value => matches(value.name)(name))}#};
}#}    values.push(...{#:filter;reveal{filtered}#}{#:filter;-reveal{values}#});
  }
}#}}`} class="s05 self-center"/>
	<p-notes p-fragment p-group="name">So let's add the name</p-notes>
	<p-notes p-fragment p-group="filter">Then filter using the name</p-notes>
</p-slide>
<p-slide>
	<!--- So, instead of using the `chainInject` function we've seen before... -->
	<Code code={`import fruitTableConfig from './fruit-table';
import { mergeConfigs } from '../utils/table';
import { chainInject{#:byName;reveal{ByName}#} } from '../chain-inject';

@Component({
	selector: 'my-fruits',
	template: '<my-table [config]="config"/>'
	providers: [fruitTableConfig],
	standalone: true
})
export class FruitList {
	configs: TableConfig[] = chainInject{#:byName;reveal{ByName}#}(TABLE_CONFIG{#:byName;reveal{, 'fruit'}#});

	config = mergeConfigs(this.configs{#:noFilter;strike{.filter(cfg => cfg.name === 'fruit')}#});
}`} class="s05 self-center"/>
	<p-notes p-group="byName">&hellip; we use this new <code>chainInjectByName</code>&hellip;</p-notes>
	<p-notes p-group="noFilter">&hellip; that automatically filters the values we're interested in for us.</p-notes>
</p-slide>
<p-slide>
	<div class="h1 center bold">The two hardest problems in IT</div>
	<ol class="self-center">
		<li p-fragment>Cache invalidation</li>
		<li p-fragment>Naming things</li>
		<li p-fragment>Off-by-one errors<!--- And I must admit, Copilot got the joke quite well here --></li>
	</ol>
</p-slide>
<p-slide>
	<Code code={`[
  provideTableConfig({
{#insert{{#insert{    name: 'ðŸ¤”',
}#}    columns: [...],
    actions: [...],
    itemsPerPage: 20,
    select: 'checkbox'
}#}  })
]`} class="s08 self-center"/>
</p-slide>

