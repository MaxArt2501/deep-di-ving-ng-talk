---
import Code from '../components/Code.astro';
---
<p-slide>
	<!--- This is fine, but we have to write every time something like this -->
	<Code code={`{#:verbose;highlight{{}#}
{#:verbose;highlight{  provide: TABLE_ACTION,}#}
{#:verbose;highlight{  useValue: }#}{#:untyped;highlight red{{}#}
{#:untyped;highlight red{    name: 'edit',}#}
{#:untyped;highlight red{    label: 'Edit',}#}
{#:untyped;highlight red{    icon: 'pencil',}#}
{#:untyped;highlight red{    link: item => [{}, item.id]}#}
{#:untyped;highlight red{  }}#},
{#:forgotten;highlight blue{  multi: true}#}
{#:verbose;highlight{}}#}`} class="self-center"/>
	<p-fragment class="annotation" p-group="verbose" style="inset: 5% auto auto 30%">Verbose ðŸ¥±<!---
		First of all, it's verbose, there's a lot of boring boilerplate --></p-fragment>
	<p-fragment class="annotation" p-group="untyped" style="inset: 40% auto auto 60%">Untyped ðŸ«£<!---
		The worst offender is the lack of type information. I can write whatever here, Angular wouldn't blink.
		In certain contexts it's vital, so it's the strength and weakness of Angular's DI system. --></p-fragment>
	<p-fragment class="annotation" p-group="forgotten" style="inset: 70% auto auto 47%">Always forgotten ðŸ˜…<!---
		Lastly, we're going to forget to write the multi: true part. Ask me how I know --></p-fragment>
</p-slide>
<style lang="scss">
	.annotation {
		position: absolute;
		background: #aaa;
		padding: .25em .5em;
		border-radius: .5em;
	}
</style>
<p-slide>
	<!--- Hear me out. What if we could have a function that helps us creating these values? For example, one that defines an action for the rows of a table -->
	<p-notes p-group="param">It will take the "real" value we want to provide, already constraining it to its correct type</p-notes>
	<p-notes p-group="boiler">Then adds all the boring parts for us</p-notes>
	<div flex="column" class="s05 gap-1 self-center">
		<Code code={`const provideTableAction{#:param;reveal{ =}#}
{#:param;insert{  (action: TableAction) => {#:boiler;reveal{(}#}{
}#}{#:boiler;insert{    provide: TABLE_ACTION,
    useValue: action,
    multi: true
}#}{#:param;insert{  }{#:boiler;reveal{)}#};}#}`}/>
		<p-notes p-group="usage">So instead of writing all of this</p-notes>
		<p-notes p-group="provide">we're reduced to write *only* the interesting parts. And we can do even better</p-notes>
    <Code code={`{
  providers: [
    {#:provide;reveal{provideTableAction(}#}{
{#:provide;-insert{      provide: TABLE_ACTION,
      useValue: {
}#}      {#:provide;-reveal{  }#}name: 'edit',
      {#:provide;-reveal{  }#}label: 'Edit',
      {#:provide;-reveal{  }#}icon: 'pencil',
      {#:provide;-reveal{  }#}link: item => ['/items', item.id]
{#:provide;-insert{      },
      multi: true
}#}    }{#:provide;reveal{)}#}
  ]
}`} p-fragment p-effect="insert" p-group="usage"/>
	</div>
</p-slide>
<p-slide>
	<!--- Instead of doing this for every token we're going to create, we can develop a factory for this kind of provider functions. What's going to need? -->
	<p-notes p-group="token">But the token, of course. As I mentioned it could be anything, but let's restrict to InjectionTokens only, for type's sake</p-notes>
	<p-notes p-group="core">The core part is just that: returns a provider object like before</p-notes>
	<p-notes p-group="types">Then we add the type generics, and we could already call it a day. But we want <em>flexibility</em></p-notes>
	<p-notes p-group="fn">So we say our value could also be a <em>factory</em> of values</p-notes>
	<p-notes p-group="factory">And return a <code>FactoryProvider</code> in this case</p-notes>
	<p-notes p-group="interface">The final step is to give appropriate types to it all</p-notes>
	<p-notes p-group="usage">and use this factory to generate our provider functions</p-notes>
	<p-notes p-group="all">All of them. But&hellip; can we do better? There's still something that&hellip; clicks "verbosity"</p-notes>
	<Code code={`{#5:interface;insert{interface ValueOrFactoryProviderFn<T> {
  (value: T): ValueProvider;
  (value: () => T): FactoryProvider;
}}#}function createTokenProvider{#2:types;reveal{<T>}#}({#0:token;reveal{token: InjectionToken{#:types;reveal{<T[]>}#}}#}) {
{#:core;insert{  return {#:interface;reveal{(}#}(value{#:types;reveal{: T}#}{#3:fn;reveal{ | (() => T)}#}) => ({
    provide: token,
{#4:factory;insert{    ...(typeof value === 'function'
      ? { useFactory: value }
}#}    {#:factory;reveal{  : { }#}useValue: value{#:factory;reveal{ })}#},
    multi: true
  }){#:interface;reveal{) as ValueOrFactoryProviderFn<T>}#};
}#}}
{#:usage;insert{
const {#:all;highlight{provideTableAction}#} = createTokenProvider(TABLE_ACTION);
}#}{#:all;insert{const {#:all;highlight{provideTableConfig}#} = createTokenProvider(TABLE_CONFIG);
const {#:all;highlight{provideTableColumn}#} = createTokenProvider(TABLE_COLUMN);}#}
`} class="s05 self-center"/>
</p-slide>
<p-slide>
	<!--- To have a peek at the issue, let's start with a token value for a particular table configuration -->
	<div grid="2" class="gap-1 s05 self-center">
		<Code code="TABLE_CONFIG" style="grid-column-end: span 2" class="center s2"/>
		<Code code={`{
  name: '{#1:same;highlight blue{articles-item-tags}#}',
  columns: [...],
  actions: [...]
}`}/>
		<Code code={`{
  name: '{#:same;highlight blue{articles-item-tags}#}',
  actions: [...]
}`} p-fragment>
			<p-notes>Making changes on this configuration is now easy</p-notes>
		</Code>
		<p-notes p-group="same">We just need to use the same name</p-notes>
		<Code code={`{
  name: '{#:diff;highlight{articles-item-category}#}',
  columns: [...],
  actions: [...]
}`} p-fragment>
			<p-notes>But suppose there's a similar table with a slightly different configuration</p-notes>
		</Code>
		<p-notes p-group="diff">and obviously a slightly different name. And suppose we want to add a change to both
			(e.g. a set of common columns or actions), without repeating the values for both names</p-notes>
		<Code code={`{
  name: '{#:wild;highlight green{articles-item-*}#}',
  columns: [...],
  actions: [...]
}`} p-fragment p-effect="reveal">
			<p-notes>How about something like this then?</p-notes>
		</Code>
		<p-notes p-group="wild">Using a wildcard to express this multiplicity? We'll need to change our chainInject fn</p-notes>
	</div>
</p-slide>
<p-slide>
	<Code code={`{#2:filter;insert{import { isMatch } from 'micromatch';

}#}export function chainInject{#:name;reveal{ByName}#}<T>(
  token: ProviderToken<T | T[]>{#:name;reveal{,}#}
{#:name;insert{  name: string
}#}): T[] {
{#:retrieve;insert{  ...
  const value = injector.get(token, null, { self: true, optional: true });
  if (value) {
    const valueArray = Array.isArray(value) ? value : [value];
{#:filter;insert{    const filtered = valueArray{#:filter;highlight green{.filter(value => isMatch(name, value.name))}#};
}#}    values.push(...{#:filter;reveal{filtered}#}{#:filter;-reveal{values}#});
  }
}#}}`} class="s05 self-center"/>
	<p-notes p-fragment p-group="name">So let's add the name as a function parameter</p-notes>
	<p-notes p-fragment p-group="retrieve">Then get the values from the injector as usual</p-notes>
	<p-notes p-fragment p-group="filter">Then filter by the name, using a common wildcard matching library</p-notes>
</p-slide>
<p-slide>
	<!--- So, instead of using the `chainInject` function we've seen before... -->
	<Code code={`import fruitTableConfig from './fruit-table';
import { mergeConfigs } from '../utils/table';
import { chainInject{#:byName;reveal{ByName}#} } from '../chain-inject';

@Component({
  selector: 'my-fruits',
  template: '<my-table [config]="config"/>'
  providers: [fruitTableConfig],
  standalone: true
})
export class FruitList {
  configs: TableConfig[] = chainInject{#:byName;reveal{ByName}#}(TABLE_CONFIG{#:byName;reveal{, 'fruit'}#});

  config = mergeConfigs(this.configs{#:noFilter;strike{.filter(cfg => cfg.name === 'fruit')}#});
}`} class="s05 self-center"/>
	<p-notes p-group="byName">&hellip; we use this new <code>chainInjectByName</code>&hellip;</p-notes>
	<p-notes p-group="noFilter">&hellip; that automatically filters the values we're interested in for us.</p-notes>
	<p-notes p-group="noFilter">But can we do better?!</p-notes>
</p-slide>
